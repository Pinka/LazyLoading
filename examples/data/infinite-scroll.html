<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Data Lazy Loading - Infinite Scroll</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }

      h1,
      h2,
      h3 {
        color: #333;
      }

      .explanation {
        background-color: #f8f9fa;
        border-left: 4px solid #007bff;
        padding: 15px;
        margin-bottom: 20px;
      }

      .post {
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 15px;
        margin-bottom: 15px;
        background-color: white;
        transition: transform 0.2s;
      }

      .post:hover {
        transform: translateY(-3px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      .post h3 {
        margin-top: 0;
        color: #007bff;
      }

      .post-body {
        color: #555;
      }

      .post-meta {
        font-size: 0.85em;
        color: #777;
        margin-top: 10px;
        display: flex;
        justify-content: space-between;
      }

      .loading {
        text-align: center;
        padding: 20px;
        font-style: italic;
        color: #666;
      }

      .loading::after {
        content: "Loading more posts...";
      }

      .loading-spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(0, 0, 0, 0.1);
        border-radius: 50%;
        border-top-color: #007bff;
        animation: spin 1s ease-in-out infinite;
        margin-right: 10px;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      pre {
        background-color: #f1f1f1;
        padding: 15px;
        border-radius: 4px;
        overflow-x: auto;
        font-family: monospace;
      }

      code {
        background-color: #f1f1f1;
        padding: 2px 4px;
        border-radius: 4px;
        font-family: monospace;
      }

      .network-info {
        background-color: #e9f7ef;
        padding: 15px;
        border-radius: 4px;
        margin-top: 20px;
      }

      #posts-container {
        min-height: 300px;
      }

      .scroll-top {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        font-size: 20px;
        cursor: pointer;
        display: none;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      .scroll-top:hover {
        background-color: #0056b3;
      }
    </style>
  </head>
  <body>
    <h1>Data Lazy Loading - Infinite Scroll</h1>

    <div class="explanation">
      <h2>How It Works</h2>
      <p>
        This example demonstrates data lazy loading using the infinite scroll
        technique. Instead of loading all data at once, new content is loaded as
        the user scrolls down the page.
      </p>
      <p>Benefits of data lazy loading:</p>
      <ul>
        <li>Reduces initial data transfer</li>
        <li>Improves page load performance</li>
        <li>Saves server resources</li>
        <li>Provides a seamless user experience</li>
        <li>Handles large datasets efficiently</li>
      </ul>
      <p>
        Scroll down to see more posts load automatically. Open your browser's
        developer tools (Network tab) to observe when new data is fetched.
      </p>
    </div>

    <div id="posts-container">
      <!-- Posts will be loaded here -->
    </div>

    <div id="loading-indicator" class="loading" style="display: none">
      <div class="loading-spinner"></div>
    </div>

    <button id="scroll-top" class="scroll-top" title="Go to top">↑</button>

    <div class="network-info">
      <h2>What to Observe</h2>
      <p>In your browser's developer tools (Network tab):</p>
      <ul>
        <li>Initial data load is small (only the first batch of posts)</li>
        <li>Additional data is loaded only when you scroll near the bottom</li>
        <li>Each request fetches a new "page" of data</li>
        <li>
          Notice how the loading is triggered before you reach the very bottom
        </li>
      </ul>
    </div>

    <div class="explanation">
      <h2>The Code</h2>
      <h3>Intersection Observer for Infinite Scroll</h3>
      <pre>
// Create an Intersection Observer to detect when the loading indicator is visible
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    // When loading indicator is visible and we're not already loading
    if (entry.isIntersecting && !isLoading) {
      loadMorePosts();
    }
  });
}, {
  // Start loading when indicator is 200px away
  rootMargin: '200px 0px',
  threshold: 0.1
});

// Observe the loading indicator
observer.observe(document.getElementById('loading-indicator'));
        </pre
      >

      <h3>Loading Data in Batches</h3>
      <pre>
async function loadMorePosts() {
  if (isLoading || noMorePosts) return;
  
  isLoading = true;
  loadingIndicator.style.display = 'block';
  
  try {
    // In a real app, this would be an API call with pagination
    // For example: fetch(`/api/posts?page=${currentPage}&limit=10`)
    const response = await fetchPostsData(currentPage, 5);
    
    if (response.posts.length === 0) {
      noMorePosts = true;
      loadingIndicator.textContent = 'No more posts to load';
      return;
    }
    
    // Render the new posts
    response.posts.forEach(post => {
      postsContainer.appendChild(createPostElement(post));
    });
    
    currentPage++;
  } catch (error) {
    console.error('Error loading posts:', error);
    loadingIndicator.textContent = 'Error loading posts. Try again later.';
  } finally {
    isLoading = false;
    
    // Hide loading indicator if no more posts
    if (noMorePosts) {
      loadingIndicator.style.display = 'none';
    }
  }
}
        </pre
      >
    </div>

    <p><a href="../index.html">Back to Examples</a></p>

    <script>
      // DOM elements
      const postsContainer = document.getElementById("posts-container");
      const loadingIndicator = document.getElementById("loading-indicator");
      const scrollTopButton = document.getElementById("scroll-top");

      // State variables
      let currentPage = 1;
      let isLoading = false;
      let noMorePosts = false;

      // Mock data - in a real app, this would come from an API
      function generateMockPosts(page, limit) {
        const posts = [];
        const startIndex = (page - 1) * limit + 1;

        for (let i = 0; i < limit; i++) {
          const postIndex = startIndex + i;
          // Only generate up to 30 posts total
          if (postIndex > 30) break;

          posts.push({
            id: postIndex,
            title: `Post ${postIndex}: ${getRandomTitle()}`,
            body: getRandomBody(),
            author: getRandomName(),
            date: getRandomDate(),
            likes: Math.floor(Math.random() * 100),
          });
        }

        return posts;
      }

      // Simulate API fetch with delay
      function fetchPostsData(page, limit) {
        return new Promise((resolve) => {
          // Simulate network delay
          setTimeout(() => {
            const posts = generateMockPosts(page, limit);
            resolve({ posts, page, totalPages: 6 });
          }, 800); // 800ms delay to simulate network request
        });
      }

      // Create a post element
      function createPostElement(post) {
        const postElement = document.createElement("div");
        postElement.className = "post";
        postElement.innerHTML = `
                <h3>${post.title}</h3>
                <div class="post-body">${post.body}</div>
                <div class="post-meta">
                    <span>By ${post.author} on ${post.date}</span>
                    <span>❤️ ${post.likes} likes</span>
                </div>
            `;
        return postElement;
      }

      // Load more posts
      async function loadMorePosts() {
        if (isLoading || noMorePosts) return;

        isLoading = true;
        loadingIndicator.style.display = "block";

        try {
          // In a real app, this would be an API call with pagination
          const response = await fetchPostsData(currentPage, 5);

          if (response.posts.length === 0) {
            noMorePosts = true;
            loadingIndicator.textContent = "No more posts to load";
            return;
          }

          // Render the new posts
          response.posts.forEach((post) => {
            postsContainer.appendChild(createPostElement(post));
          });

          currentPage++;

          // If we've reached the last page
          if (currentPage > response.totalPages) {
            noMorePosts = true;
            loadingIndicator.innerHTML = "End of content";
          }
        } catch (error) {
          console.error("Error loading posts:", error);
          loadingIndicator.innerHTML = "Error loading posts. Try again later.";
        } finally {
          isLoading = false;

          // Hide loading indicator if no more posts
          if (noMorePosts) {
            setTimeout(() => {
              loadingIndicator.style.display = "none";
            }, 2000);
          }
        }
      }

      // Initial load
      loadMorePosts();

      // Create an Intersection Observer to detect when the loading indicator is visible
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            // When loading indicator is visible and we're not already loading
            if (entry.isIntersecting && !isLoading && !noMorePosts) {
              loadMorePosts();
            }
          });
        },
        {
          // Start loading when indicator is 200px away
          rootMargin: "200px 0px",
          threshold: 0.1,
        }
      );

      // Observe the loading indicator
      observer.observe(loadingIndicator);

      // Show/hide scroll to top button
      window.addEventListener("scroll", () => {
        if (window.pageYOffset > 300) {
          scrollTopButton.style.display = "block";
        } else {
          scrollTopButton.style.display = "none";
        }
      });

      // Scroll to top when button is clicked
      scrollTopButton.addEventListener("click", () => {
        window.scrollTo({
          top: 0,
          behavior: "smooth",
        });
      });

      // Helper functions for generating random content
      function getRandomTitle() {
        const titles = [
          "Understanding Lazy Loading",
          "Performance Optimization Techniques",
          "Web Development Best Practices",
          "Modern JavaScript Features",
          "Building Responsive Websites",
          "CSS Grid Layout Tutorial",
          "Mastering Flexbox",
          "Progressive Web Apps",
          "Frontend Development Tips",
          "Optimizing Web Performance",
        ];
        return titles[Math.floor(Math.random() * titles.length)];
      }

      function getRandomBody() {
        const bodies = [
          "Lazy loading is a design pattern commonly used in web development to defer initialization of an object until the point at which it is needed. It can contribute to efficiency in the program's operation if properly and appropriately used.",
          "Web performance optimization is the field of knowledge about increasing web performance. Faster websites have better user experience, conversion rates, and higher ranks in organic search results.",
          "Responsive web design is an approach to web design that makes web pages render well on a variety of devices and window or screen sizes. Recent work also considers the viewer proximity as part of the viewing context as an extension for RWD.",
          "JavaScript is a programming language that conforms to the ECMAScript specification. JavaScript is high-level, often just-in-time compiled, and multi-paradigm. It has curly-bracket syntax, dynamic typing, prototype-based object-orientation, and first-class functions.",
          "CSS Grid Layout excels at dividing a page into major regions or defining the relationship in terms of size, position, and layer, between parts of a control built from HTML primitives.",
          "Flexbox is a one-dimensional layout method for laying out items in rows or columns. Items flex to fill additional space and shrink to fit into smaller spaces.",
          "Progressive Web Apps are web apps that use service workers, manifests, and other web-platform features in combination with progressive enhancement to give users an experience on par with native apps.",
        ];
        return bodies[Math.floor(Math.random() * bodies.length)];
      }

      function getRandomName() {
        const names = [
          "Alex Johnson",
          "Sam Smith",
          "Jordan Lee",
          "Taylor Brown",
          "Casey Wilson",
          "Morgan Davis",
          "Jamie Miller",
          "Riley Anderson",
        ];
        return names[Math.floor(Math.random() * names.length)];
      }

      function getRandomDate() {
        const months = [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec",
        ];
        const month = months[Math.floor(Math.random() * months.length)];
        const day = Math.floor(Math.random() * 28) + 1;
        const year = 2023;
        return `${month} ${day}, ${year}`;
      }
    </script>
  </body>
</html>
